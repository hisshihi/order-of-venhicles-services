// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order_response.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countOrderResponsesByOrderId = `-- name: CountOrderResponsesByOrderId :one
SELECT COUNT(*) FROM order_responses
WHERE order_id = $1
`

// Подсчитывает количество откликов на конкретный заказ
// Входные параметры: ID заказа
// Возвращает: количество откликов (число)
func (q *Queries) CountOrderResponsesByOrderId(ctx context.Context, orderID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrderResponsesByOrderId, orderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrderResponse = `-- name: CreateOrderResponse :one
INSERT INTO order_responses (
    order_id, 
    provider_id, 
    message, 
    offered_price, 
    is_selected
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, order_id, provider_id, message, offered_price, is_selected, created_at, updated_at
`

type CreateOrderResponseParams struct {
	OrderID      int64          `json:"order_id"`
	ProviderID   int64          `json:"provider_id"`
	Message      sql.NullString `json:"message"`
	OfferedPrice sql.NullString `json:"offered_price"`
	IsSelected   sql.NullBool   `json:"is_selected"`
}

// Создает новый отклик на заказ от провайдера услуг
// Входные параметры: ID заказа, ID провайдера, сообщение, предложенная цена, выбран ли отклик
// Возвращает: созданную запись отклика
func (q *Queries) CreateOrderResponse(ctx context.Context, arg CreateOrderResponseParams) (OrderResponse, error) {
	row := q.db.QueryRowContext(ctx, createOrderResponse,
		arg.OrderID,
		arg.ProviderID,
		arg.Message,
		arg.OfferedPrice,
		arg.IsSelected,
	)
	var i OrderResponse
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProviderID,
		&i.Message,
		&i.OfferedPrice,
		&i.IsSelected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrderResponse = `-- name: DeleteOrderResponse :exec
DELETE FROM order_responses
WHERE id = $1
`

// Удаляет отклик по его ID
// Входные параметры: ID отклика
// Возвращает: ничего
func (q *Queries) DeleteOrderResponse(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrderResponse, id)
	return err
}

const getOrderResponseById = `-- name: GetOrderResponseById :one
SELECT id, order_id, provider_id, message, offered_price, is_selected, created_at, updated_at FROM order_responses
WHERE id = $1
LIMIT 1
`

// Получает отклик по его ID
// Входные параметры: ID отклика
// Возвращает: запись отклика или ничего, если отклик не найден
func (q *Queries) GetOrderResponseById(ctx context.Context, id int64) (OrderResponse, error) {
	row := q.db.QueryRowContext(ctx, getOrderResponseById, id)
	var i OrderResponse
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProviderID,
		&i.Message,
		&i.OfferedPrice,
		&i.IsSelected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderResponseByOrderAndProvider = `-- name: GetOrderResponseByOrderAndProvider :one
SELECT id, order_id, provider_id, message, offered_price, is_selected, created_at, updated_at FROM order_responses
WHERE order_id = $1 AND provider_id = $2
LIMIT 1
`

type GetOrderResponseByOrderAndProviderParams struct {
	OrderID    int64 `json:"order_id"`
	ProviderID int64 `json:"provider_id"`
}

// Проверяет наличие отклика от конкретного провайдера на конкретный заказ
// Входные параметры: ID заказа, ID провайдера
// Возвращает: запись отклика или ничего, если отклик не найден
func (q *Queries) GetOrderResponseByOrderAndProvider(ctx context.Context, arg GetOrderResponseByOrderAndProviderParams) (OrderResponse, error) {
	row := q.db.QueryRowContext(ctx, getOrderResponseByOrderAndProvider, arg.OrderID, arg.ProviderID)
	var i OrderResponse
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProviderID,
		&i.Message,
		&i.OfferedPrice,
		&i.IsSelected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderResponsesByOrderId = `-- name: GetOrderResponsesByOrderId :many
SELECT r.id, r.order_id, r.provider_id, r.message, r.offered_price, r.is_selected, r.created_at, r.updated_at, u.username, u.phone, u.whatsapp, u.photo_url
FROM order_responses r
JOIN users u ON r.provider_id = u.id
WHERE r.order_id = $1
ORDER BY r.created_at
`

type GetOrderResponsesByOrderIdRow struct {
	ID           int64          `json:"id"`
	OrderID      int64          `json:"order_id"`
	ProviderID   int64          `json:"provider_id"`
	Message      sql.NullString `json:"message"`
	OfferedPrice sql.NullString `json:"offered_price"`
	IsSelected   sql.NullBool   `json:"is_selected"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	Username     string         `json:"username"`
	Phone        string         `json:"phone"`
	Whatsapp     string         `json:"whatsapp"`
	PhotoUrl     []byte         `json:"photo_url"`
}

// Получает все отклики для конкретного заказа с информацией о провайдерах
// Входные параметры: ID заказа
// Возвращает: список откликов с данными провайдеров (имя, телефон, whatsapp, фото)
func (q *Queries) GetOrderResponsesByOrderId(ctx context.Context, orderID int64) ([]GetOrderResponsesByOrderIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderResponsesByOrderId, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderResponsesByOrderIdRow{}
	for rows.Next() {
		var i GetOrderResponsesByOrderIdRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProviderID,
			&i.Message,
			&i.OfferedPrice,
			&i.IsSelected,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Phone,
			&i.Whatsapp,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderResponsesByProviderId = `-- name: GetOrderResponsesByProviderId :many
SELECT r.id, r.order_id, r.provider_id, r.message, r.offered_price, r.is_selected, r.created_at, r.updated_at, o.client_id, o.category_id, o.service_id, o.status, o.client_message, o.order_date
FROM order_responses r
JOIN orders o ON r.order_id = o.id
WHERE r.provider_id = $1
ORDER BY r.created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrderResponsesByProviderIdParams struct {
	ProviderID int64 `json:"provider_id"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

type GetOrderResponsesByProviderIdRow struct {
	ID            int64            `json:"id"`
	OrderID       int64            `json:"order_id"`
	ProviderID    int64            `json:"provider_id"`
	Message       sql.NullString   `json:"message"`
	OfferedPrice  sql.NullString   `json:"offered_price"`
	IsSelected    sql.NullBool     `json:"is_selected"`
	CreatedAt     time.Time        `json:"created_at"`
	UpdatedAt     time.Time        `json:"updated_at"`
	ClientID      int64            `json:"client_id"`
	CategoryID    int64            `json:"category_id"`
	ServiceID     sql.NullInt64    `json:"service_id"`
	Status        NullStatusOrders `json:"status"`
	ClientMessage sql.NullString   `json:"client_message"`
	OrderDate     sql.NullTime     `json:"order_date"`
}

// Получает все отклики, созданные конкретным провайдером, с информацией о связанных заказах
// Входные параметры: ID провайдера, лимит и смещение для пагинации
// Возвращает: список откликов с основной информацией о заказах
func (q *Queries) GetOrderResponsesByProviderId(ctx context.Context, arg GetOrderResponsesByProviderIdParams) ([]GetOrderResponsesByProviderIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderResponsesByProviderId, arg.ProviderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderResponsesByProviderIdRow{}
	for rows.Next() {
		var i GetOrderResponsesByProviderIdRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProviderID,
			&i.Message,
			&i.OfferedPrice,
			&i.IsSelected,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClientID,
			&i.CategoryID,
			&i.ServiceID,
			&i.Status,
			&i.ClientMessage,
			&i.OrderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersWithResponsesByProvider = `-- name: GetOrdersWithResponsesByProvider :many
SELECT DISTINCT o.id, o.client_id, o.category_id, o.service_id, o.status, o.created_at, o.updated_at, o.provider_accepted, o.provider_message, o.client_message, o.order_date, o.selected_provider_id, u.username AS client_username, sc.name AS category_name
FROM orders o
JOIN users u ON o.client_id = u.id
JOIN service_categories sc ON o.category_id = sc.id
JOIN order_responses r ON o.id = r.order_id
WHERE r.provider_id = $1
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersWithResponsesByProviderParams struct {
	ProviderID int64 `json:"provider_id"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

type GetOrdersWithResponsesByProviderRow struct {
	ID                 int64            `json:"id"`
	ClientID           int64            `json:"client_id"`
	CategoryID         int64            `json:"category_id"`
	ServiceID          sql.NullInt64    `json:"service_id"`
	Status             NullStatusOrders `json:"status"`
	CreatedAt          time.Time        `json:"created_at"`
	UpdatedAt          time.Time        `json:"updated_at"`
	ProviderAccepted   sql.NullBool     `json:"provider_accepted"`
	ProviderMessage    sql.NullString   `json:"provider_message"`
	ClientMessage      sql.NullString   `json:"client_message"`
	OrderDate          sql.NullTime     `json:"order_date"`
	SelectedProviderID sql.NullInt64    `json:"selected_provider_id"`
	ClientUsername     string           `json:"client_username"`
	CategoryName       string           `json:"category_name"`
}

// Получает все заказы, на которые провайдер оставил отклики (даже если не выбран)
// Входные параметры: ID провайдера, лимит и смещение для пагинации
// Возвращает: список заказов с базовой информацией о клиенте и категории
func (q *Queries) GetOrdersWithResponsesByProvider(ctx context.Context, arg GetOrdersWithResponsesByProviderParams) ([]GetOrdersWithResponsesByProviderRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersWithResponsesByProvider, arg.ProviderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersWithResponsesByProviderRow{}
	for rows.Next() {
		var i GetOrdersWithResponsesByProviderRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CategoryID,
			&i.ServiceID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProviderAccepted,
			&i.ProviderMessage,
			&i.ClientMessage,
			&i.OrderDate,
			&i.SelectedProviderID,
			&i.ClientUsername,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersWithSelectedProvider = `-- name: GetOrdersWithSelectedProvider :many
SELECT o.id, o.client_id, o.category_id, o.service_id, o.status, o.created_at, o.updated_at, o.provider_accepted, o.provider_message, o.client_message, o.order_date, o.selected_provider_id, u.username AS client_username, u.phone AS client_phone, u.whatsapp AS client_whatsapp,
       sc.name AS category_name, p.username AS provider_username
FROM orders o
JOIN users u ON o.client_id = u.id
JOIN service_categories sc ON o.category_id = sc.id
LEFT JOIN users p ON o.selected_provider_id = p.id
WHERE o.selected_provider_id IS NOT NULL
ORDER BY o.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetOrdersWithSelectedProviderParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetOrdersWithSelectedProviderRow struct {
	ID                 int64            `json:"id"`
	ClientID           int64            `json:"client_id"`
	CategoryID         int64            `json:"category_id"`
	ServiceID          sql.NullInt64    `json:"service_id"`
	Status             NullStatusOrders `json:"status"`
	CreatedAt          time.Time        `json:"created_at"`
	UpdatedAt          time.Time        `json:"updated_at"`
	ProviderAccepted   sql.NullBool     `json:"provider_accepted"`
	ProviderMessage    sql.NullString   `json:"provider_message"`
	ClientMessage      sql.NullString   `json:"client_message"`
	OrderDate          sql.NullTime     `json:"order_date"`
	SelectedProviderID sql.NullInt64    `json:"selected_provider_id"`
	ClientUsername     string           `json:"client_username"`
	ClientPhone        string           `json:"client_phone"`
	ClientWhatsapp     string           `json:"client_whatsapp"`
	CategoryName       string           `json:"category_name"`
	ProviderUsername   sql.NullString   `json:"provider_username"`
}

// Получает список заказов, для которых выбран провайдер, с детальной информацией
// Входные параметры: лимит и смещение для пагинации
// Возвращает: список заказов с данными о клиенте, категории и провайдере
func (q *Queries) GetOrdersWithSelectedProvider(ctx context.Context, arg GetOrdersWithSelectedProviderParams) ([]GetOrdersWithSelectedProviderRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersWithSelectedProvider, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersWithSelectedProviderRow{}
	for rows.Next() {
		var i GetOrdersWithSelectedProviderRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CategoryID,
			&i.ServiceID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProviderAccepted,
			&i.ProviderMessage,
			&i.ClientMessage,
			&i.OrderDate,
			&i.SelectedProviderID,
			&i.ClientUsername,
			&i.ClientPhone,
			&i.ClientWhatsapp,
			&i.CategoryName,
			&i.ProviderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSelectedProviderForOrder = `-- name: GetSelectedProviderForOrder :one
SELECT u.id, u.username, u.email, u.password_hash, u.password_change_at, u.role, u.country, u.city, u.district, u.phone, u.whatsapp, u.created_at, u.updated_at, u.photo_url, u.description, u.is_verified, u.is_blocked FROM users u
JOIN orders o ON u.id = o.selected_provider_id
WHERE o.id = $1
LIMIT 1
`

// Получает данные выбранного провайдера для конкретного заказа
// Входные параметры: ID заказа
// Возвращает: запись пользователя-провайдера или ничего, если провайдер не выбран
func (q *Queries) GetSelectedProviderForOrder(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getSelectedProviderForOrder, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordChangeAt,
		&i.Role,
		&i.Country,
		&i.City,
		&i.District,
		&i.Phone,
		&i.Whatsapp,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhotoUrl,
		&i.Description,
		&i.IsVerified,
		&i.IsBlocked,
	)
	return i, err
}

const getSelectedResponseForOrder = `-- name: GetSelectedResponseForOrder :one
SELECT r.id, r.order_id, r.provider_id, r.message, r.offered_price, r.is_selected, r.created_at, r.updated_at FROM order_responses r
WHERE r.order_id = $1 AND r.is_selected = true
LIMIT 1
`

// Получает выбранный отклик для конкретного заказа
// Входные параметры: ID заказа
// Возвращает: запись выбранного отклика или ничего, если отклик не выбран
func (q *Queries) GetSelectedResponseForOrder(ctx context.Context, orderID int64) (OrderResponse, error) {
	row := q.db.QueryRowContext(ctx, getSelectedResponseForOrder, orderID)
	var i OrderResponse
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProviderID,
		&i.Message,
		&i.OfferedPrice,
		&i.IsSelected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasProviderRespondedToOrder = `-- name: HasProviderRespondedToOrder :one
SELECT EXISTS (
    SELECT 1 FROM order_responses
    WHERE order_id = $1 AND provider_id = $2
) AS has_responded
`

type HasProviderRespondedToOrderParams struct {
	OrderID    int64 `json:"order_id"`
	ProviderID int64 `json:"provider_id"`
}

// Проверяет, откликнулся ли провайдер на заказ
// Входные параметры: ID заказа, ID провайдера
// Возвращает: булево значение (true/false)
func (q *Queries) HasProviderRespondedToOrder(ctx context.Context, arg HasProviderRespondedToOrderParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasProviderRespondedToOrder, arg.OrderID, arg.ProviderID)
	var has_responded bool
	err := row.Scan(&has_responded)
	return has_responded, err
}

const selectProviderForOrder = `-- name: SelectProviderForOrder :one
WITH selected_response AS (
    UPDATE order_responses
    SET 
        is_selected = true,
        updated_at = now()
    WHERE id = $1
    RETURNING id, order_id, provider_id, message, offered_price, is_selected, created_at, updated_at
)
UPDATE orders
SET 
    selected_provider_id = (SELECT provider_id FROM selected_response),
    status = 'accepted',
    updated_at = now()
WHERE id = (SELECT order_id FROM selected_response)
RETURNING id, client_id, category_id, service_id, status, created_at, updated_at, provider_accepted, provider_message, client_message, order_date, selected_provider_id
`

// Выбирает провайдера для выполнения заказа (транзакционный запрос)
// Обновляет статус отклика на "выбран" и устанавливает выбранного провайдера в заказе
// Входные параметры: ID отклика
// Возвращает: обновленную запись заказа
func (q *Queries) SelectProviderForOrder(ctx context.Context, dollar_1 sql.NullInt64) (Order, error) {
	row := q.db.QueryRowContext(ctx, selectProviderForOrder, dollar_1)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CategoryID,
		&i.ServiceID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProviderAccepted,
		&i.ProviderMessage,
		&i.ClientMessage,
		&i.OrderDate,
		&i.SelectedProviderID,
	)
	return i, err
}

const unselectProviderForOrder = `-- name: UnselectProviderForOrder :execrows
WITH unselect_response AS (
    UPDATE order_responses
    SET 
        is_selected = false,
        updated_at = now()
    WHERE id = $1
    RETURNING order_id
)
UPDATE orders
SET 
    selected_provider_id = NULL,
    status = 'pending',
    updated_at = now()
WHERE id = (SELECT order_id FROM unselect_response)
`

// Отменяет выбор провайдера для заказа (транзакционный запрос)
// Сбрасывает статус отклика и очищает поле выбранного провайдера в заказе
// Входные параметры: ID отклика
// Возвращает: количество обновленных строк (должно быть 1)
func (q *Queries) UnselectProviderForOrder(ctx context.Context, dollar_1 sql.NullInt64) (int64, error) {
	result, err := q.db.ExecContext(ctx, unselectProviderForOrder, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateOrderResponse = `-- name: UpdateOrderResponse :one
UPDATE order_responses
SET 
    message = $2,
    offered_price = $3,
    updated_at = now()
WHERE id = $1
RETURNING id, order_id, provider_id, message, offered_price, is_selected, created_at, updated_at
`

type UpdateOrderResponseParams struct {
	ID           int64          `json:"id"`
	Message      sql.NullString `json:"message"`
	OfferedPrice sql.NullString `json:"offered_price"`
}

// Обновляет информацию в существующем отклике
// Входные параметры: ID отклика, новое сообщение, новая предложенная цена
// Возвращает: обновленную запись отклика
func (q *Queries) UpdateOrderResponse(ctx context.Context, arg UpdateOrderResponseParams) (OrderResponse, error) {
	row := q.db.QueryRowContext(ctx, updateOrderResponse, arg.ID, arg.Message, arg.OfferedPrice)
	var i OrderResponse
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProviderID,
		&i.Message,
		&i.OfferedPrice,
		&i.IsSelected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
