// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: service.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countService = `-- name: CountService :one
SELECT COUNT(*) FROM "services"
`

func (q *Queries) CountService(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countService)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServicesByProviderID = `-- name: CountServicesByProviderID :one
SELECT COUNT(*) FROM "services"
WHERE provider_id = $1
`

func (q *Queries) CountServicesByProviderID(ctx context.Context, providerID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countServicesByProviderID, providerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createService = `-- name: CreateService :one
INSERT INTO "services" (
        provider_id,
        category_id,
        subtitle_category_id,
        subcategory,
        title,
        description,
        price,
        country,
        city,
        district
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, provider_id, category_id, title, description, price, created_at, updated_at, subcategory, country, city, district, subtitle_category_id
`

type CreateServiceParams struct {
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	Subcategory        sql.NullString `json:"subcategory"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, createService,
		arg.ProviderID,
		arg.CategoryID,
		arg.SubtitleCategoryID,
		arg.Subcategory,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Country,
		arg.City,
		arg.District,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.CategoryID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subcategory,
		&i.Country,
		&i.City,
		&i.District,
		&i.SubtitleCategoryID,
	)
	return i, err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM "services"
WHERE id = $1
    AND provider_id = $2
`

type DeleteServiceParams struct {
	ID         int64 `json:"id"`
	ProviderID int64 `json:"provider_id"`
}

func (q *Queries) DeleteService(ctx context.Context, arg DeleteServiceParams) error {
	_, err := q.db.ExecContext(ctx, deleteService, arg.ID, arg.ProviderID)
	return err
}

const deleteServicesByCategoryID = `-- name: DeleteServicesByCategoryID :execrows
DELETE FROM services
WHERE category_id = $1
`

func (q *Queries) DeleteServicesByCategoryID(ctx context.Context, categoryID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteServicesByCategoryID, categoryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteServicesBySubcategoryID = `-- name: DeleteServicesBySubcategoryID :execrows
DELETE FROM services
WHERE subtitle_category_id = $1
`

func (q *Queries) DeleteServicesBySubcategoryID(ctx context.Context, subtitleCategoryID sql.NullInt64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteServicesBySubcategoryID, subtitleCategoryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const filterServiceByPrice = `-- name: FilterServiceByPrice :many
SELECT id, provider_id, category_id, title, description, price, created_at, updated_at, subcategory, country, city, district, subtitle_category_id FROM "services"
WHERE price >= $1 AND price <= $2
`

type FilterServiceByPriceParams struct {
	Price   string `json:"price"`
	Price_2 string `json:"price_2"`
}

// Фильтрация услуг по цене
func (q *Queries) FilterServiceByPrice(ctx context.Context, arg FilterServiceByPriceParams) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, filterServiceByPrice, arg.Price, arg.Price_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    u.username as provider_name,
    u.photo_url as provider_photo,
    u.phone as provider_phone,
    u.whatsapp as provider_whatsapp,
    sc.name as category_name,
    (
        SELECT COUNT(*)
        FROM "reviews" r
        WHERE r.provider_id = s.provider_id
    ) as reviews_count,
    (
        SELECT COALESCE(AVG(r.rating), 0)
        FROM "reviews" r
        WHERE r.provider_id = s.provider_id
    ) as average_rating
FROM "services" s
    JOIN "users" u ON s.provider_id = u.id
    JOIN "service_categories" sc ON s.category_id = sc.id
WHERE s.id = $1
`

type GetServiceByIDRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	ProviderName       string         `json:"provider_name"`
	ProviderPhoto      []byte         `json:"provider_photo"`
	ProviderPhone      string         `json:"provider_phone"`
	ProviderWhatsapp   string         `json:"provider_whatsapp"`
	CategoryName       string         `json:"category_name"`
	ReviewsCount       int64          `json:"reviews_count"`
	AverageRating      sql.NullString `json:"average_rating"`
}

func (q *Queries) GetServiceByID(ctx context.Context, id int64) (GetServiceByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceByID, id)
	var i GetServiceByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.CategoryID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subcategory,
		&i.Country,
		&i.City,
		&i.District,
		&i.SubtitleCategoryID,
		&i.ProviderName,
		&i.ProviderPhoto,
		&i.ProviderPhone,
		&i.ProviderWhatsapp,
		&i.CategoryName,
		&i.ReviewsCount,
		&i.AverageRating,
	)
	return i, err
}

const getServicesByProviderID = `-- name: GetServicesByProviderID :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    sc.name as category_name
FROM "services" s
    JOIN "service_categories" sc ON s.category_id = sc.id
WHERE s.provider_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type GetServicesByProviderIDParams struct {
	ProviderID int64 `json:"provider_id"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

type GetServicesByProviderIDRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	CategoryName       string         `json:"category_name"`
}

func (q *Queries) GetServicesByProviderID(ctx context.Context, arg GetServicesByProviderIDParams) ([]GetServicesByProviderIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getServicesByProviderID, arg.ProviderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServicesByProviderIDRow{}
	for rows.Next() {
		var i GetServicesByProviderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountServicesByCatetegory = `-- name: ListCountServicesByCatetegory :one
SELECT COUNT(*) FROM "services"
WHERE category_id = $1
`

func (q *Queries) ListCountServicesByCatetegory(ctx context.Context, categoryID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, listCountServicesByCatetegory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listServices = `-- name: ListServices :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    u.username as provider_name,
    u.photo_url as provider_photo,
    sc.name as category_name
FROM "services" s
    JOIN "users" u ON s.provider_id = u.id
    JOIN "service_categories" sc ON s.category_id = sc.id
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListServicesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListServicesRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	ProviderName       string         `json:"provider_name"`
	ProviderPhoto      []byte         `json:"provider_photo"`
	CategoryName       string         `json:"category_name"`
}

func (q *Queries) ListServices(ctx context.Context, arg ListServicesParams) ([]ListServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, listServices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicesRow{}
	for rows.Next() {
		var i ListServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.ProviderName,
			&i.ProviderPhoto,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByCategory = `-- name: ListServicesByCategory :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    u.username as provider_name,
    u.photo_url as provider_photo,
    sc.name as category_name
FROM "services" s
    JOIN "users" u ON s.provider_id = u.id
    JOIN "service_categories" sc ON s.category_id = sc.id
WHERE s.category_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type ListServicesByCategoryParams struct {
	CategoryID int64 `json:"category_id"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

type ListServicesByCategoryRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	ProviderName       string         `json:"provider_name"`
	ProviderPhoto      []byte         `json:"provider_photo"`
	CategoryName       string         `json:"category_name"`
}

func (q *Queries) ListServicesByCategory(ctx context.Context, arg ListServicesByCategoryParams) ([]ListServicesByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listServicesByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicesByCategoryRow{}
	for rows.Next() {
		var i ListServicesByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.ProviderName,
			&i.ProviderPhoto,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByLocation = `-- name: ListServicesByLocation :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    u.username as provider_name,
    u.photo_url as provider_photo,
    sc.name as category_name
FROM "services" s
    JOIN "users" u ON s.provider_id = u.id
    JOIN "service_categories" sc ON s.category_id = sc.id
WHERE (
        $1::text IS NULL
        OR s.country = $1
    )
    AND (
        $2::text IS NULL
        OR s.city = $2
    )
    AND (
        $3::text IS NULL
        OR s.district = $3
    )
ORDER BY s.created_at DESC
LIMIT $4 OFFSET $5
`

type ListServicesByLocationParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int64  `json:"limit"`
	Offset  int64  `json:"offset"`
}

type ListServicesByLocationRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	ProviderName       string         `json:"provider_name"`
	ProviderPhoto      []byte         `json:"provider_photo"`
	CategoryName       string         `json:"category_name"`
}

func (q *Queries) ListServicesByLocation(ctx context.Context, arg ListServicesByLocationParams) ([]ListServicesByLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, listServicesByLocation,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicesByLocationRow{}
	for rows.Next() {
		var i ListServicesByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.ProviderName,
			&i.ProviderPhoto,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProviderIDAndCategory = `-- name: ListServicesByProviderIDAndCategory :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    sc.name as category_name
FROM "services" s
    JOIN "service_categories" sc ON s.category_id = sc.id
WHERE s.provider_id = $1
    AND s.category_id = $2
`

type ListServicesByProviderIDAndCategoryParams struct {
	ProviderID int64 `json:"provider_id"`
	CategoryID int64 `json:"category_id"`
}

type ListServicesByProviderIDAndCategoryRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	CategoryName       string         `json:"category_name"`
}

func (q *Queries) ListServicesByProviderIDAndCategory(ctx context.Context, arg ListServicesByProviderIDAndCategoryParams) ([]ListServicesByProviderIDAndCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listServicesByProviderIDAndCategory, arg.ProviderID, arg.CategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicesByProviderIDAndCategoryRow{}
	for rows.Next() {
		var i ListServicesByProviderIDAndCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProviderIDAndSubCategory = `-- name: ListServicesByProviderIDAndSubCategory :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    sc.name as subcategory_name
FROM "services" s
    JOIN "subtitle_category" sc ON s.subtitle_category_id = sc.id
WHERE s.provider_id = $1
    AND s.subtitle_category_id = $2
`

type ListServicesByProviderIDAndSubCategoryParams struct {
	ProviderID         int64         `json:"provider_id"`
	SubtitleCategoryID sql.NullInt64 `json:"subtitle_category_id"`
}

type ListServicesByProviderIDAndSubCategoryRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	SubcategoryName    string         `json:"subcategory_name"`
}

func (q *Queries) ListServicesByProviderIDAndSubCategory(ctx context.Context, arg ListServicesByProviderIDAndSubCategoryParams) ([]ListServicesByProviderIDAndSubCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listServicesByProviderIDAndSubCategory, arg.ProviderID, arg.SubtitleCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicesByProviderIDAndSubCategoryRow{}
	for rows.Next() {
		var i ListServicesByProviderIDAndSubCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.SubcategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServices = `-- name: SearchServices :many
SELECT s.id, s.provider_id, s.category_id, s.title, s.description, s.price, s.created_at, s.updated_at, s.subcategory, s.country, s.city, s.district, s.subtitle_category_id,
    u.username as provider_name,
    u.photo_url as provider_photo,
    sc.name as category_name
FROM "services" s
    JOIN "users" u ON s.provider_id = u.id
    JOIN "service_categories" sc ON s.category_id = sc.id
WHERE (
        to_tsvector('simple', s.title) @@ to_tsquery('simple', $1)
        OR to_tsvector('simple', s.description) @@ to_tsquery('simple', $1)
        OR s.title ILIKE '%' || $1 || '%'
        OR s.description ILIKE '%' || $1 || '%'
    )
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchServicesParams struct {
	ToTsquery string `json:"to_tsquery"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

type SearchServicesRow struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	Subcategory        sql.NullString `json:"subcategory"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
	ProviderName       string         `json:"provider_name"`
	ProviderPhoto      []byte         `json:"provider_photo"`
	CategoryName       string         `json:"category_name"`
}

func (q *Queries) SearchServices(ctx context.Context, arg SearchServicesParams) ([]SearchServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchServices, arg.ToTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchServicesRow{}
	for rows.Next() {
		var i SearchServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.CategoryID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Subcategory,
			&i.Country,
			&i.City,
			&i.District,
			&i.SubtitleCategoryID,
			&i.ProviderName,
			&i.ProviderPhoto,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateService = `-- name: UpdateService :one
UPDATE "services"
SET category_id = $3,
    subcategory = $4,
    title = $5,
    description = $6,
    price = $7,
    country = $8,
    city = $9,
    district = $10,
    subtitle_category_id = $11,
    updated_at = NOW()
WHERE id = $1
    AND provider_id = $2
RETURNING id, provider_id, category_id, title, description, price, created_at, updated_at, subcategory, country, city, district, subtitle_category_id
`

type UpdateServiceParams struct {
	ID                 int64          `json:"id"`
	ProviderID         int64          `json:"provider_id"`
	CategoryID         int64          `json:"category_id"`
	Subcategory        sql.NullString `json:"subcategory"`
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	Price              string         `json:"price"`
	Country            sql.NullString `json:"country"`
	City               sql.NullString `json:"city"`
	District           sql.NullString `json:"district"`
	SubtitleCategoryID sql.NullInt64  `json:"subtitle_category_id"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, updateService,
		arg.ID,
		arg.ProviderID,
		arg.CategoryID,
		arg.Subcategory,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Country,
		arg.City,
		arg.District,
		arg.SubtitleCategoryID,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.CategoryID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subcategory,
		&i.Country,
		&i.City,
		&i.District,
		&i.SubtitleCategoryID,
	)
	return i, err
}
